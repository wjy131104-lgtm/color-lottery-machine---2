<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ë¬¼ë¦¬ êµ¬ì¡° ì‹¤í—˜ì‹¤</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1e1e1e; font-family: 'Malgun Gothic', sans-serif; user-select: none; }
        
        /* UI íŒ¨ë„ ìŠ¤íƒ€ì¼ */
        #ui {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.8); padding: 15px;
            border-radius: 8px; border: 1px solid #444; color: white;
            display: flex; flex-direction: column; gap: 10px;
        }
        button {
            padding: 8px; background: #444; color: white; border: none; cursor: pointer; border-radius: 4px; font-weight: bold;
        }
        button:hover { background: #666; }
        button.active { background: #ff4757; color: white; }
        .info { font-size: 12px; color: #aaa; margin-top: 5px; }
        
        #canvas { cursor: crosshair; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">ğŸ› ï¸ ìì¬ ì„ íƒ</div>
        <button onclick="setMaterial('wood')" id="btn-wood" class="active">ğŸªµ ë‚˜ë¬´ (ê°€ë³ê³  ì˜ ë¶€ëŸ¬ì§)</button>
        <button onclick="setMaterial('steel')" id="btn-steel">â›“ï¸ ê°•ì²  (ë¬´ê²ê³  íŠ¼íŠ¼í•¨)</button>
        <button onclick="setMaterial('gold')" id="btn-gold">ğŸª™ ê¸ˆ (ì•„ì£¼ ë¬´ê²ê³  ë¬´ë¦„)</button>
        <hr style="width: 100%; border: 0.5px solid #555;">
        <button onclick="spawnWeight()">âš–ï¸ 100kg ë¬´ê²Œì¶” íˆ¬í•˜</button>
        <button onclick="resetSim()">ğŸ”„ ì´ˆê¸°í™”</button>
        <div class="info">
            ì¢Œí´ë¦­ ë“œë˜ê·¸: êµ¬ì¡°ë¬¼ ê±´ì„¤ (ìš©ì ‘)<br>
            ìš°í´ë¦­: êµ¬ì¡°ë¬¼ ì‚­ì œ/ì ˆë‹¨<br>
            ë¹¨ê°„ìƒ‰ ì„ : íŒŒì† ìœ„í—˜ (ì‘ë ¥ ì§‘ì¤‘)
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ë¬¼ë¦¬ ì—”ì§„ ì„¤ì •
        const gravity = 0.5;
        const friction = 0.99;
        const bounce = 0.7;

        // ì¬ë£Œ ì†ì„± DB
        const MATERIALS = {
            wood:  { color: '#8B4513', strength: 1.1, weight: 1, stiff: 0.5 }, // strength: ëŠì–´ì§€ëŠ” í•œê³„
            steel: { color: '#A9A9A9', strength: 2.5, weight: 2, stiff: 1.0 },
            gold:  { color: '#FFD700', strength: 1.5, weight: 5, stiff: 0.2 }
        };

        let currentMat = 'wood';
        let points = [];
        let sticks = [];

        // ë§ˆìš°ìŠ¤ ìƒí˜¸ì‘ìš© ë³€ìˆ˜
        let isDragging = false;
        let dragStartPoint = null;
        let mouseX, mouseY;

        // === ë¬¼ë¦¬ í´ë˜ìŠ¤ ì •ì˜ ===
        class Point {
            constructor(x, y, pinned = false, mass = 1) {
                this.x = x;
                this.y = y;
                this.oldx = x;
                this.oldy = y;
                this.pinned = pinned; // ê³ ì •ëœ ì ì¸ê°€? (ë°”ë‹¥ ë“±)
                this.mass = mass;
            }

            update() {
                if (this.pinned) return;
                
                // Verlet Integration (ì†ë„ = í˜„ì¬ìœ„ì¹˜ - ì´ì „ìœ„ì¹˜)
                let vx = (this.x - this.oldx) * friction;
                let vy = (this.y - this.oldy) * friction;

                this.oldx = this.x;
                this.oldy = this.y;

                this.x += vx;
                this.y += vy;
                this.y += gravity * this.mass; // ì§ˆëŸ‰ì— ë”°ë¥¸ ì¤‘ë ¥ ê°€ì†

                // ë°”ë‹¥ ì¶©ëŒ
                if (this.y > canvas.height) {
                    this.y = canvas.height;
                    this.oldy = this.y + vy * bounce;
                }
            }
        }

        class Stick {
            constructor(p1, p2, materialKey) {
                this.p1 = p1;
                this.p2 = p2;
                this.mat = MATERIALS[materialKey];
                this.length = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                this.active = true;
            }

            update() {
                if (!this.active) return;

                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const dist = Math.hypot(dx, dy);
                
                // íŒŒì† ë¡œì§: ì›ë˜ ê¸¸ì´ë³´ë‹¤ ì¼ì • ë¹„ìœ¨ ì´ìƒ ëŠ˜ì–´ë‚˜ë©´ ëŠì–´ì§
                // strengthê°€ ë‚®ì„ìˆ˜ë¡ ì˜ ëŠì–´ì§
                const stress = dist / this.length;
                if (stress > this.mat.strength) {
                    this.active = false; // ëš ëŠì–´ì§
                    return;
                }

                // ê¸¸ì´ ë³´ì • (ìŠ¤í”„ë§ì²˜ëŸ¼ ì›ë˜ ê¸¸ì´ë¡œ ëŒì•„ê°€ë ¤ëŠ” í˜)
                const difference = this.length - dist;
                const percent = difference / dist / 2;
                const offsetX = dx * percent * this.mat.stiff; // stiffê°€ ë†’ìœ¼ë©´ ë”±ë”±í•¨
                const offsetY = dy * percent * this.mat.stiff;

                if (!this.p1.pinned) {
                    this.p1.x -= offsetX;
                    this.p1.y -= offsetY;
                }
                if (!this.p2.pinned) {
                    this.p2.x += offsetX;
                    this.p2.y += offsetY;
                }
            }

            draw() {
                if (!this.active) return;
                
                // ì‘ë ¥ ì‹œê°í™”: ë§ì´ ëŠ˜ì–´ë‚ ìˆ˜ë¡ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë³€í•¨
                const stress = Math.hypot(this.p2.x - this.p1.x, this.p2.y - this.p1.y) / this.length;
                let color = this.mat.color;
                
                if (stress > this.mat.strength * 0.8) {
                    color = '#ff0000'; // ëŠì–´ì§€ê¸° ì§ì „ ê²½ê³ 
                    ctx.lineWidth = 3;
                } else {
                    ctx.lineWidth = 2 + (this.mat.weight * 0.5); // ë¬´ê±°ìš´ ì¬ì§ˆì€ ë‘ê»ê²Œ
                }

                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
            }
        }

        // === ì‹œë®¬ë ˆì´ì…˜ ì œì–´ í•¨ìˆ˜ ===
        function setMaterial(mat) {
            currentMat = mat;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mat}`).classList.add('active');
        }

        function spawnWeight() {
            // ë¬´ê±°ìš´ ì‚¬ê°í˜• íˆ¬í•˜
            let startX = window.innerWidth / 2;
            let startY = 50;
            let w = 40;
            
            // ì  4ê°œ ìƒì„±
            let p1 = new Point(startX, startY, false, 5);
            let p2 = new Point(startX + w, startY, false, 5);
            let p3 = new Point(startX + w, startY + w, false, 5);
            let p4 = new Point(startX, startY + w, false, 5);
            
            points.push(p1, p2, p3, p4);

            // ì„œë¡œ ì—°ê²°í•´ì„œ ë‹¨ë‹¨í•œ ë©ì–´ë¦¬ë¡œ ë§Œë“¦ (Xì í¬í•¨)
            sticks.push(new Stick(p1, p2, 'steel'));
            sticks.push(new Stick(p2, p3, 'steel'));
            sticks.push(new Stick(p3, p4, 'steel'));
            sticks.push(new Stick(p4, p1, 'steel'));
            sticks.push(new Stick(p1, p3, 'steel')); // ëŒ€ê°ì„  ì§€ì§€ëŒ€
            sticks.push(new Stick(p2, p4, 'steel'));
        }

        function resetSim() {
            points = [];
            sticks = [];
            // ê¸°ë³¸ ë°”ë‹¥ ìƒì„±
            createBase();
        }

        function createBase() {
            // ë°”ë‹¥ì— ê³ ì •ì  2ê°œ ìƒì„±
            let p1 = new Point(window.innerWidth / 2 - 200, window.innerHeight - 100, true);
            let p2 = new Point(window.innerWidth / 2 + 200, window.innerHeight - 100, true);
            points.push(p1, p2);
        }

        // === ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ===
        // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸° (ìš©ì ‘ìš©)
        function findNearestPoint(x, y) {
            let nearest = null;
            let minDist = 20; // 20px ì´ë‚´ë©´ ë¶™ìŒ
            for (let p of points) {
                let d = Math.hypot(p.x - x, p.y - y);
                if (d < minDist) {
                    minDist = d;
                    nearest = p;
                }
            }
            return nearest;
        }

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) return; // ìš°í´ë¦­ ë¬´ì‹œ
            
            isDragging = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            // ê¸°ì¡´ ì  ê·¼ì²˜ì—ì„œ ì‹œì‘í•˜ë©´ ê·¸ ì ì„ ì„ íƒ, ì•„ë‹ˆë©´ ìƒˆ ì  ìƒì„±
            let existing = findNearestPoint(mouseX, mouseY);
            if (existing) {
                dragStartPoint = existing;
            } else {
                let newP = new Point(mouseX, mouseY, false, MATERIALS[currentMat].weight);
                points.push(newP);
                dragStartPoint = newP;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDragging) return;
            isDragging = false;
            
            // ë“œë˜ê·¸ ëë‚œ ìœ„ì¹˜ì— ì  ìƒì„± ë˜ëŠ” ì—°ê²°
            let endPoint = findNearestPoint(mouseX, mouseY);
            if (!endPoint) {
                endPoint = new Point(mouseX, mouseY, false, MATERIALS[currentMat].weight);
                points.push(endPoint);
            }

            // ì‹œì‘ì ê³¼ ëì ì´ ë‹¤ë¥´ë©´ ì—°ê²° (ìš©ì ‘)
            if (dragStartPoint !== endPoint) {
                sticks.push(new Stick(dragStartPoint, endPoint, currentMat));
            }
            dragStartPoint = null;
        });
        
        // ìš°í´ë¦­ ì‚­ì œ
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // ë§ˆìš°ìŠ¤ ê·¼ì²˜ì˜ ì ê³¼ ì„  ì‚­ì œ
            let mx = e.clientX, my = e.clientY;
            sticks = sticks.filter(s => {
                // ì„ ê³¼ ì  ì‚¬ì´ ê±°ë¦¬ ê³„ì‚° (ì ê³¼ ì§ì„  ì‚¬ì´ ê±°ë¦¬ ê³µì‹)
                let dist = Math.abs((s.p2.y - s.p1.y)*mx - (s.p2.x - s.p1.x)*my + s.p2.x*s.p1.y - s.p2.y*s.p1.x) / 
                           Math.hypot(s.p2.y - s.p1.y, s.p2.x - s.p1.x);
                return dist > 10; // 10px ì´ë‚´ë©´ ì‚­ì œ
            });
        });

        // === ë©”ì¸ ë£¨í”„ ===
        createBase();

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ (ë°˜ë³µ íšŸìˆ˜ê°€ ë§ì„ìˆ˜ë¡ ì•ˆì •ì )
            for (let i = 0; i < 3; i++) {
                points.forEach(p => p.update());
                sticks.forEach(s => s.update());
            }

            // ê·¸ë¦¬ê¸°
            sticks.forEach(s => s.draw());
            
            // ì  ê·¸ë¦¬ê¸° (ìš©ì ‘ í¬ì¸íŠ¸)
            ctx.fillStyle = '#fff';
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // ë“œë˜ê·¸ ì¤‘ì¸ ì„  ë¯¸ë¦¬ë³´ê¸°
            if (isDragging && dragStartPoint) {
                ctx.beginPath();
                ctx.strokeStyle = '#666';
                ctx.setLineDash([5, 5]);
                ctx.moveTo(dragStartPoint.x, dragStartPoint.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            requestAnimationFrame(animate);
        }

        animate();
        
        // ì°½ í¬ê¸° ì¡°ì ˆ
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            resetSim();
        });

    </script>
</body>
</html>