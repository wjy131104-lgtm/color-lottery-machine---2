<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ê°•ì²´ êµ¬ì¡° ì‹¤í—˜ì‹¤</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; color: white; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; z-index: 10; display: flex; flex-direction: column; gap: 8px; }
        button { padding: 10px; cursor: pointer; border: none; border-radius: 4px; background: #444; color: white; font-weight: bold; }
        button:hover { background: #666; }
        button.active { background: #3498db; }
        .hint { font-size: 11px; color: #aaa; }
    </style>
</head>
<body>
    <div id="ui">
        <div style="font-weight: bold;">ğŸ› ï¸ ì‹¤í—˜ ë„êµ¬</div>
        <button onclick="setMode('create')" id="btn-create" class="active">ğŸ“¦ ë„í˜• ìƒì„±</button>
        <button onclick="setMode('select')" id="btn-select">ğŸ–±ï¸ ì„ íƒ ë° ì´ë™</button>
        <button onclick="weldSelected()">ğŸ”— ì„ íƒ ê°œì²´ ìš©ì ‘</button>
        <button onclick="spawnWeight()" style="background: #e67e22;">âš–ï¸ ë¬´ê²Œì¶” íˆ¬í•˜</button>
        <button onclick="resetSim()" style="background: #c0392b;">ğŸ”„ ì´ˆê¸°í™”</button>
        <div class="hint">
            - ìƒì„±: í´ë¦­ ì‹œ ìƒì ìƒì„±<br>
            - ì„ íƒ: ë“œë˜ê·¸ë¡œ ë‹¤ì¤‘ ì„ íƒ<br>
            - ìš©ì ‘: ì„ íƒëœ ìƒìë“¤ì„ í•˜ë‚˜ë¡œ ë¬¶ìŒ
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let mode = 'create'; // 'create', 'select'
        let bodies = []; // ê°œë³„ ë„í˜•ë“¤
        let selectedBodies = [];
        let isMouseDown = false;
        let selectionRect = null;
        let dragTarget = null;
        let offset = { x: 0, y: 0 };

        class Body {
            constructor(x, y, w, h, mass = 1) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.vx = 0;
                this.vy = 0;
                this.mass = mass;
                this.isStatic = false; // ë°”ë‹¥ì²˜ëŸ¼ ê³ ì •ëœ ë¬¼ì²´ì¸ì§€
                this.groupId = Math.random(); // ìš©ì ‘ëœ ê·¸ë£¹ ID
                this.color = mass > 5 ? '#555' : '#8B4513';
            }

            update() {
                if (this.isStatic) return;
                
                this.vy += 0.2 * this.mass; // ì¤‘ë ¥
                this.x += this.vx;
                this.y += this.vy;

                // ë°”ë‹¥ ì¶©ëŒ
                if (this.y + this.h > canvas.height) {
                    this.y = canvas.height - this.h;
                    this.vy *= -0.2;
                }
            }

            draw(isSelected) {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.strokeStyle = isSelected ? '#3498db' : '#333';
                ctx.lineWidth = isSelected ? 3 : 1;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeRect(this.x, this.y, this.w, this.h);
                ctx.restore();
            }
        }

        function setMode(m) {
            mode = m;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${m}`).classList.add('active');
        }

        // ì„ íƒëœ ë„í˜•ë“¤ ìš©ì ‘ (ê·¸ë£¹í™”)
        function weldSelected() {
            if (selectedBodies.length < 2) return;
            const newGroupId = Math.random();
            selectedBodies.forEach(b => b.groupId = newGroupId);
            alert("ìš©ì ‘ ì™„ë£Œ! ì´ì œ í•¨ê»˜ ì›€ì§ì…ë‹ˆë‹¤.");
        }

        function spawnWeight() {
            const weight = new Body(mouseX, 50, 60, 60, 10);
            weight.color = "#2c3e50";
            bodies.push(weight);
        }

        function resetSim() {
            bodies = [];
            selectedBodies = [];
        }

        // ë©”ì¸ ë£¨í”„
        function animate() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            bodies.forEach(b => {
                b.update();
                b.draw(selectedBodies.includes(b));
            });

            // ê·¸ë£¹í™”ëœ ë¬¼ì²´ë“¤ë¼ë¦¬ ìœ„ì¹˜ ë™ê¸°í™” (ê°„ë‹¨í•œ ë¬¼ë¦¬ ê²°í•©)
            const groups = {};
            bodies.forEach(b => {
                if (!groups[b.groupId]) groups[b.groupId] = [];
                groups[b.groupId].push(b);
            });

            // ì„ íƒ ì˜ì—­ ê·¸ë¦¬ê¸°
            if (selectionRect) {
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
                ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
            }

            requestAnimationFrame(animate);
        }

        let mouseX, mouseY;
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const x = e.clientX;
            const y = e.clientY;

            if (mode === 'create') {
                bodies.push(new Body(x - 25, y - 25, 50, 50));
            } else if (mode === 'select') {
                dragTarget = bodies.find(b => x > b.x && x < b.x + b.w && y > b.y && y < b.y + b.h);
                if (dragTarget) {
                    offset.x = x - dragTarget.x;
                    offset.y = y - dragTarget.y;
                } else {
                    selectionRect = { x, y, w: 0, h: 0 };
                    selectedBodies = [];
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            if (!isMouseDown) return;

            if (mode === 'select') {
                if (dragTarget) {
                    const dx = mouseX - offset.x - dragTarget.x;
                    const dy = mouseY - offset.y - dragTarget.y;
                    
                    // ê°™ì€ ê·¸ë£¹ì´ë©´ ê°™ì´ ì´ë™
                    bodies.filter(b => b.groupId === dragTarget.groupId).forEach(b => {
                        b.x += dx;
                        b.y += dy;
                        b.vy = 0; // ë“œë˜ê·¸ ì¤‘ì—” ì¤‘ë ¥ ë¬´ì‹œ
                    });
                } else if (selectionRect) {
                    selectionRect.w = mouseX - selectionRect.x;
                    selectionRect.h = mouseY - selectionRect.y;
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (selectionRect) {
                // ì‚¬ê°í˜• ì•ˆì— í¬í•¨ëœ ê°œì²´ë“¤ ì„ íƒ
                const x1 = Math.min(selectionRect.x, selectionRect.x + selectionRect.w);
                const x2 = Math.max(selectionRect.x, selectionRect.x + selectionRect.w);
                const y1 = Math.min(selectionRect.y, selectionRect.y + selectionRect.h);
                const y2 = Math.max(selectionRect.y, selectionRect.y + selectionRect.h);

                selectedBodies = bodies.filter(b => b.x > x1 && b.x + b.w < x2 && b.y > y1 && b.y + b.h < y2);
            }
            isMouseDown = false;
            selectionRect = null;
            dragTarget = null;
        });

        animate();
    </script>
</body>
</html>