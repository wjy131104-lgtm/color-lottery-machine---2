<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>정밀 물리 유리 파괴</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; cursor: crosshair; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let shards = [];
        let isBroken = false;

        class Shard {
            constructor(points, centerX, centerY, targetX, targetY) {
                this.points = points; // 다각형 꼭짓점들
                this.x = centerX;
                this.y = centerY;
                
                // 폭발 물리: 충격 지점에서 멀어지는 방향으로 가속도 부여
                const angle = Math.atan2(centerY - targetY, centerX - targetX);
                const dist = Math.hypot(centerX - targetX, centerY - targetY);
                const force = (500 / (dist + 50)) * 10; // 가까울수록 강한 힘

                this.vx = Math.cos(angle) * force + (Math.random() - 0.5) * 5;
                this.vy = Math.sin(angle) * force + (Math.random() - 0.5) * 5;
                
                this.rotation = 0;
                this.vRotation = (Math.random() - 0.5) * 0.4; // 회전 속도
                
                this.gravity = 0.6;
                this.friction = 0.98; // 공기 저항
                this.bounce = -0.4;   // 바닥 탄성
                this.alpha = 1;
            }

            update() {
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.vRotation;

                // 바닥 충돌 물리
                if (this.y > canvas.height - 20) {
                    this.y = canvas.height - 20;
                    this.vy *= this.bounce;
                    this.vRotation *= 0.8; // 마찰로 회전 감소
                }
                
                this.alpha -= 0.005;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.alpha;
                
                // 유리 질감 렌더링
                ctx.fillStyle = "rgba(180, 220, 255, 0.4)";
                ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                ctx.lineWidth = 1.5;

                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for(let i=1; i<this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // 유리 반사광 효과
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                ctx.lineTo(this.points[1].x, this.points[1].y);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.stroke();

                ctx.restore();
            }
        }

        function createGlass(targetX, targetY) {
            const rows = 12;
            const cols = 10;
            const w = 300 / cols;
            const h = 400 / rows;
            const startX = canvas.width / 2 - 150;
            const startY = canvas.height / 2 - 200;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    // 각 조각을 불규칙한 다각형으로 생성
                    const px = startX + i * w;
                    const py = startY + j * h;
                    
                    const points = [
                        {x: -w/2, y: -h/2}, {x: w/2, y: -h/2}, 
                        {x: w/2, y: h/2}, {x: -w/2, y: h/2}
                    ].map(p => ({
                        x: p.x + (Math.random() - 0.5) * 15,
                        y: p.y + (Math.random() - 0.5) * 15
                    }));

                    shards.push(new Shard(points, px + w/2, py + h/2, targetX, targetY));
                }
            }
        }

        function animate() {
            ctx.fillStyle = '#050508';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!isBroken) {
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.strokeRect(canvas.width/2 - 150, canvas.height/2 - 200, 300, 400);
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.fillText("유리를 클릭해서 파괴하세요", canvas.width/2, canvas.height/2);
            }

            shards.forEach((s, i) => {
                s.update();
                s.draw();
                if (s.alpha <= 0) shards.splice(i, 1);
            });

            requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousedown', (e) => {
            if(!isBroken) {
                isBroken = true;
                createGlass(e.clientX, e.clientY);
            } else if (shards.length === 0) {
                isBroken = false;
            }
        });

        animate();
    </script>
</body>
</html>